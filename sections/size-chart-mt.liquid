{% stylesheet %}
  .size-chart-section {
    --section-padding: var(--spacing-md, 16px);
    --table-border-radius: 8px;
    --table-gap: var(--spacing-lg, 24px);
    --table-header-bg: #f0f8ff;
    --table-row-even-bg: #fafafa;
    --table-row-odd-bg: #ffffff;
    --table-border-color: #eee;
    padding-block-start: var(--padding-block-start, clamp(24px, 5vw, 48px));
    padding-block-end: var(--padding-block-end, clamp(24px, 5vw, 48px));
  }

  .product-info__main-title {
    margin: 0 0 clamp(24px, 4vw, 48px) 0 !important;
  }

  @media (min-width: 990px) {
    .size-chart-section {
      --table-gap: clamp(32px, 4vw, 48px);
      padding-block-start: var(--padding-block-start, clamp(48px, 6vw, 72px));
      padding-block-end: var(--padding-block-end, clamp(48px, 6vw, 72px));
    }
  }

  .custom-size_chart {
    max-width: 1200px;
    margin: 0 auto;
    display: block;
  }

  .size-chart-section > .product-info__main-title.h4 {
    max-width: 1200px;
    margin: 0 auto clamp(24px, 4vw, 48px) auto;
    padding: 0 var(--spacing-md, 0);
    text-align: left !important;
  }

  .product-info__main-title {
    font-family: var(--font-primary--family);
    font-size: var(--font-h4--size);
    font-weight: var(--font-h4--weight);
    color: var(--font-h4--color);
    line-height: var(--font-h4--line-height);
    text-align: left !important;
    margin-bottom: clamp(24px, 4vw, 48px);
  }

  .size-chart-section .table-container {
    width: 100%;
    margin: 0 auto 24px auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    overflow: hidden;
  }

  .size-chart-section table {
    width: 100%;
    border-collapse: collapse;
  }

  .size-chart-section thead {
    background: #f0f8ff;
    color: #333;
    text-align: left;
  }

  .size-chart-section th,
  .size-chart-section td {
    padding: 12px 16px;
    text-align: left;
    border-bottom: 1px solid #eee;
  }

  .size-chart-section th {
    background: #f0f8ff;
    color: #333;
    font-weight: bold;
    font-size: 16px;
  }

  .size-chart-section th:first-child {
    width: 20%;
    font-weight: 600;
  }

  .size-chart-section tr:nth-child(even) {
    background: #fafafa;
  }

  .size-chart-section tr:last-child td {
    border-bottom: none;
  }

  .size-chart-section td a {
    text-decoration: none;
    color: #000;
    transition: color 0.2s ease;
  }

  .size-chart-section td .product_title_ {
    color: #4b81bf;
    text-decoration: none;
    font-size: 16px;
    line-height: 20px;
    font-weight: 600;
  }

  /* Row hover styling - V1: Shadow + Lift */
  .size-chart-section .product-row {
    cursor: pointer;
    position: relative;
    transition: all 0.3s ease;
  }

  .size-chart-section .product-row:hover {
    background-color: #f0f8ff !important;
    box-shadow: 0 2px 8px rgba(75, 129, 191, 0.15);
    transform: translateY(-1px);
  }

  .size-chart-section .price {
    color: #3cc561;
    font-weight: 600;
  }

  .size-chart-section .info-btn {
    color: white;
    padding: 10px 15px;
    text-align: center;
    display: inline-block;
    text-decoration: none;
    font-weight: bold;
    border: none;
    cursor: pointer;
    border-radius: 4px;
    background: #3cc561;
    transition: background-color 0.2s ease;
  }

  .size-chart-section .info-btn:hover {
    background: #2ea84d;
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .size-chart-section .table-container {
      width: 100%;
      overflow-x: auto;
      position: relative;
    }

    .size-chart-section table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 600px;
    }

    .size-chart-section table th:first-child,
    .size-chart-section table td:first-child {
      position: sticky;
      left: 0;
      border-right: 2px solid #eee;
      min-width: 120px;
      max-width: 120px;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .size-chart-section table td:first-child {
      background-color: #fff;
    }

    .size-chart-section table th:first-child {
      background-color: #f0f8ff;
      font-size: 14px;
      font-weight: 600;
      text-align: left;
      padding: 12px 8px;
      height: 100%;
      vertical-align: top;
    }

    .size-chart-section table th,
    .size-chart-section table td {
      min-width: 100px;
      padding: 8px;
      border-bottom: 1px solid #eee;
      text-align: left;
      font-size: 14px;
    }

    .size-chart-section table th {
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      background-color: #f0f8ff;
    }

    .size-chart-section table td:first-child a,
    .size-chart-section table th:first-child {
      display: block;
      word-break: break-word;
      line-height: 1.2;
    }

    .size-chart-section .cust_model {
      height: 125px !important;
    }
  }

  /* Accessibility improvements */
  .size-chart-section .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Performance optimizations */
  .size-chart-section {
    contain: layout;
  }

  .size-chart-section .table-container {
    will-change: auto;
  }
{% endstylesheet %}
{% if product.metafields.custom.list_product != blank or request.design_mode %}
  <div class="section-background color-{{ section.settings.color_scheme }}"></div>
  <div
    class="size-chart-section section section--page-width spacing-style color-{{ section.settings.color_scheme | default: 'scheme-1' }} relative"
    style="{% render 'spacing-style', settings: section.settings %}"
  >
    <h3 class="product-info__main-title h4">Størrelser</h3>
    <div class="page-width">
      <div id="custom-product-{{ section.id }}" class="custom-size_chart">
        <div class="custom-product-wrap">
          <div class="custom-product-container">
            {% if product.metafields.custom.list_product != blank %}
              <div class="table-container">
                <table>
                  <thead>
                    <tr>
                      <th class="cust_model">Model</th>
                      <th class="cust_hkd">
                        Udvendige mål <br>
                        (HxBxD mm)
                      </th>
                      <th class="cust_hkd">
                        Indvendige mål <br>
                        (HxBxD mm)
                      </th>
                      <th class="cust_ve">Vægt</th>
                      <th class="cust_price">Pris</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for product_ in product.metafields.custom.list_product.value %}
                      <tr class="product-row" data-product-url="{{ product_.url }}" data-product-handle="{{ product_.handle }}">
                        <td class="cut_td">
                          <span class="product_title_">{{- product_.title -}}</span>
                        </td>
                        <td class="cut_td">
                          {{- product_.metafields.custom.new_height.value | split: ' ' | first }} X
                          {{ product_.metafields.custom.new_width.value | split: ' ' | first }} X
                          {{ product_.metafields.custom.new_depth.value | split: ' ' | first -}}
                        </td>
                        <td class="cut_td">
                          {{- product_.metafields.custom.new_height_interior.value | split: ' ' | first }} X
                          {{ product_.metafields.custom.new_width_interior.value | split: ' ' | first }} X
                          {{ product_.metafields.custom.new_depth_interior.value | split: ' ' | first -}}
                        </td>
                        <td class="cut_td">
                          {% for variant in product_.variants %}
                            {% if forloop.first %}
                              <span>{{ variant.weight | divided_by: 1000 }} kg</span>
                            {% endif %}
                          {% endfor %}
                        </td>
                        <td class="cut_td">
                          From <span class="price">{{ product_.price | money_with_currency }}</span>
                        </td>
                      </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            {% else %}
              {% comment %} Editor placeholder content {% endcomment %}
              <div class="table-container" style="background: #f8f9fa; border: 2px dashed #dee2e6; border-radius: 8px; padding: 40px; text-align: center;">
                <div style="color: #6c757d; font-size: 16px; line-height: 1.5;">
                  <h4 style="color: #495057; margin: 0 0 16px 0;">Size Chart Preview</h4>
                  <p style="margin: 0 0 8px 0;">This section will display a size comparison table when:</p>
                  <ul style="list-style: none; padding: 0; margin: 0;">
                    <li style="margin: 4px 0;">• Product has related products in the "list_product" metafield</li>
                    <li style="margin: 4px 0;">• Product dimensions are configured via metafields</li>
                  </ul>
                  <p style="margin: 16px 0 0 0; font-size: 14px; color: #868e96;">Configure product metafields to see the actual size chart</p>
                </div>
              </div>
            {% endif %}
          </div>
        </div>
      </div>
    </div>
  </div>
{% endif %}

{% schema %}
{
  "name": "Size chart",
  "settings": [
    {
      "type": "color_scheme",
      "id": "color_scheme",
      "label": "t:settings.color_scheme",
      "default": "scheme-1"
    },
    {
      "type": "header",
      "content": "t:content.padding"
    },
    {
      "type": "range",
      "id": "padding-block-start",
      "label": "t:settings.top",
      "min": 0,
      "max": 100,
      "step": 1,
      "unit": "px",
      "default": 48
    },
    {
      "type": "range",
      "id": "padding-block-end",
      "label": "t:settings.bottom",
      "min": 0,
      "max": 100,
      "step": 1,
      "unit": "px",
      "default": 48
    }
  ],
  "presets": [
    {
      "name": "Size chart"
    }
  ]
}
{% endschema %}

{% javascript %}
  // Immediate execution to test if JavaScript is working
  console.log('[ProductSwitcher] Script executing at:', new Date().toISOString());

  // Performance optimization: Cache for fetched pages
  const pageCache = new Map();
  const prefetchQueue = new Set();

  // Simple function to handle clicks
  function handleProductSwitchClick(event) {
    const target = event.target.closest('.product-row');

    if (!target) {
      return;
    }

    console.log('[ProductSwitcher] Product row clicked:', target);
    event.preventDefault();

    const productUrl = target.dataset.productUrl;
    const productHandle = target.dataset.productHandle;

    if (!productUrl) {
      console.warn('[ProductSwitcher] No product URL found');
      return;
    }

    console.log('[ProductSwitcher] Switching to product:', productUrl);

    // Add loading state
    target.classList.add('loading');

    // Update URL
    window.history.pushState({}, '', productUrl);

    // Use optimized manual update with caching
    console.log('[ProductSwitcher] Using optimized manual section update');
    updateWithOptimizedApproach(productUrl, target);
  }

  // Prefetch product pages on hover for instant loading
  function handleProductHover(event) {
    const target = event.target.closest('.product-row');
    if (!target) return;

    const productUrl = target.dataset.productUrl;
    if (!productUrl || pageCache.has(productUrl) || prefetchQueue.has(productUrl)) {
      return;
    }

    prefetchQueue.add(productUrl);

    // Prefetch after a short delay to avoid excessive requests
    setTimeout(() => {
      if (prefetchQueue.has(productUrl)) {
        console.log('[ProductSwitcher] Prefetching:', productUrl);
        prefetchProductPage(productUrl);
      }
    }, 300);
  }

  // Prefetch function for hover optimization
  async function prefetchProductPage(productUrl) {
    try {
      if (pageCache.has(productUrl)) return;

      const response = await fetch(productUrl, {
        headers: {
          Accept: 'text/html',
          'X-Requested-With': 'XMLHttpRequest',
        },
      });

      if (response.ok) {
        const html = await response.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const mainSection = doc.querySelector('[id*="template--"][id*="__main"]');

        if (mainSection) {
          pageCache.set(productUrl, mainSection.cloneNode(true));
          console.log('[ProductSwitcher] Prefetched and cached:', productUrl);
        }
      }
    } catch (error) {
      console.warn('[ProductSwitcher] Prefetch failed:', error);
    } finally {
      prefetchQueue.delete(productUrl);
    }
  }

  // Optimized update with caching and better DOM handling
  async function updateWithOptimizedApproach(productUrl, target) {
    try {
      let newMainSection;

      // Check cache first
      if (pageCache.has(productUrl)) {
        console.log('[ProductSwitcher] Using cached content for:', productUrl);
        newMainSection = pageCache.get(productUrl).cloneNode(true);
      } else {
        console.log('[ProductSwitcher] Fetching and caching:', productUrl);

        const response = await fetch(productUrl, {
          headers: {
            Accept: 'text/html',
            'X-Requested-With': 'XMLHttpRequest',
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const html = await response.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        newMainSection = doc.querySelector('[id*="template--"][id*="__main"]');

        if (newMainSection) {
          // Cache for future use
          pageCache.set(productUrl, newMainSection.cloneNode(true));
        }
      }

      const currentMainSection = document.querySelector('[id*="template--"][id*="__main"]');

      if (newMainSection && currentMainSection) {
        console.log('[ProductSwitcher] Updating main product section');

        // Use more efficient DOM update with animation frame
        requestAnimationFrame(() => {
          currentMainSection.outerHTML = newMainSection.outerHTML;

          // Dispatch events for any JavaScript re-initialization
          document.dispatchEvent(new CustomEvent('theme:section:load'));
          document.dispatchEvent(
            new CustomEvent('product:switched', {
              detail: { productUrl, productHandle: target.dataset.productHandle },
            })
          );

          console.log('[ProductSwitcher] Optimized update completed successfully');
        });

        // Smooth scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        console.warn('[ProductSwitcher] Could not find main section, falling back to navigation');
        window.location.href = productUrl;
      }
    } catch (error) {
      console.error('[ProductSwitcher] Optimized update failed:', error);
      window.location.href = productUrl;
    } finally {
      target.classList.remove('loading');
    }
  }

  // Keep the original function for backward compatibility
  async function updateWithManualApproach(productUrl, target) {
    // Delegate to optimized approach
    return updateWithOptimizedApproach(productUrl, target);
  }

  async function updateSection(sectionId, url) {
    try {
      if (window.sectionRenderer?.renderSection) {
        // Use the project's section renderer
        await window.sectionRenderer.renderSection(sectionId, { url, cache: false });
      } else {
        // Manual fallback
        await manualUpdateSection(sectionId, url);
      }
    } catch (error) {
      console.error(`[ProductSwitcher] Section update failed for ${sectionId}:`, error);
      throw error;
    }
  }

  async function manualUpdateSection(sectionId, url) {
    const section = document.getElementById(sectionId);
    if (!section) {
      throw new Error(`Section ${sectionId} not found in DOM`);
    }

    // Extract section name from ID (remove shopify-section- prefix if present)
    const sectionName = sectionId.replace(/^shopify-section-/, '');

    const fetchUrl = new URL(url);
    fetchUrl.searchParams.set('section_id', sectionName);

    console.log('[ProductSwitcher] Fetching section:', fetchUrl.toString());

    const response = await fetch(fetchUrl.toString(), {
      headers: {
        Accept: 'text/html',
        'X-Requested-With': 'XMLHttpRequest',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const html = await response.text();
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const newSection = doc.getElementById(sectionId);

    if (!newSection) {
      console.warn(`[ProductSwitcher] Section ${sectionId} not found in response, trying alternatives`);
      // Try to find any section in the response
      const anySection = doc.querySelector('.shopify-section');
      if (anySection) {
        anySection.id = sectionId;
        section.outerHTML = anySection.outerHTML;
      } else {
        throw new Error(`No section content found in response`);
      }
    } else {
      section.outerHTML = newSection.outerHTML;
    }

    // Trigger section load event
    document.dispatchEvent(new CustomEvent('theme:section:load'));
  }

  async function updateWithSectionRenderer(productUrl, target) {
    try {
      const url = new URL(productUrl, window.location.origin);

      // Find product sections to update - use actual section patterns
      const productSections = document.querySelectorAll(`
        [id*="template--"][id*="__main"],
        [id*="template--"][id*="__product"],
        [id*="shopify-section-template--"][id*="main"]
      `);

      console.log('[ProductSwitcher] Found sections to update:', productSections.length);

      // Also try to find any sections that might contain product info
      const allSections = document.querySelectorAll('.shopify-section[id*="template--"]');
      console.log('[ProductSwitcher] All template sections found:', allSections.length);

      // Filter to likely product-related sections, exclude header/footer
      const relevantSections = Array.from(allSections).filter((section) => {
        const id = section.id.toLowerCase();
        // Include main product sections, exclude header/footer/announcements
        return (
          (id.includes('main') || id.includes('product') || id.includes('media') || id.includes('gallery')) &&
          !id.includes('header') &&
          !id.includes('footer') &&
          !id.includes('announcement')
        );
      });

      console.log(
        '[ProductSwitcher] Relevant sections:',
        relevantSections.map((s) => s.id)
      );

      // Update sections in parallel
      const updatePromises = relevantSections
        .map((section) => {
          if (section.id) {
            console.log('[ProductSwitcher] Updating section:', section.id);
            return updateSection(section.id, url).catch((error) => {
              console.warn(`[ProductSwitcher] Failed to update ${section.id}:`, error);
              return null; // Don't fail the whole operation
            });
          }
        })
        .filter(Boolean);

      await Promise.allSettled(updatePromises);

      // Dispatch custom event
      document.dispatchEvent(
        new CustomEvent('product:switched', {
          detail: { productUrl, productHandle: target.dataset.productHandle },
        })
      );

      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    } catch (error) {
      console.error('[ProductSwitcher] Update failed:', error);
      window.location.href = productUrl;
    } finally {
      target.classList.remove('loading');
    }
  }

  // Add styles
  function addProductSwitcherStyles() {
    if (document.getElementById('product-switcher-styles')) return;

    const style = document.createElement('style');
    style.id = 'product-switcher-styles';
    style.textContent = `
      .product-switch-link {
        transition: opacity 0.2s ease;
      }
      .product-switch-link:hover {
        opacity: 0.8;
      }
      .product-switch-link.loading {
        opacity: 0.5;
        pointer-events: none;
      }
    `;
    document.head.appendChild(style);
  }

  // Cache management
  function clearPageCache() {
    pageCache.clear();
    prefetchQueue.clear();
    console.log('[ProductSwitcher] Cache cleared');
  }

  // Limit cache size to prevent memory issues
  function manageCacheSize() {
    const MAX_CACHE_SIZE = 10;
    if (pageCache.size > MAX_CACHE_SIZE) {
      const firstKey = pageCache.keys().next().value;
      pageCache.delete(firstKey);
    }
  }

  // Initialize
  function initProductSwitcher() {
    console.log('[ProductSwitcher] Initializing optimized version...');

    // Remove any existing listeners
    document.removeEventListener('click', handleProductSwitchClick);
    document.removeEventListener('mouseover', handleProductHover);

    // Add new listeners
    document.addEventListener('click', handleProductSwitchClick);
    document.addEventListener('mouseover', handleProductHover);

    // Add styles
    addProductSwitcherStyles();

    // Clear cache on page visibility change (user switches tabs)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        manageCacheSize();
      }
    });

    console.log('[ProductSwitcher] Optimized version initialized successfully');
  }

  // Start immediately if DOM is ready, otherwise wait
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initProductSwitcher);
  } else {
    initProductSwitcher();
  }
{% endjavascript %}
